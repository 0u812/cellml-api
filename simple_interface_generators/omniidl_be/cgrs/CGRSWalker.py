# -*- python -*-
import os.path
import identifier
import string
from typeinfo import GetTypeInformation
from omniidl import idlast, idlvisitor, idlutil, idltype, output

class CGRSWalker(idlvisitor.AstVisitor):
    """Walks over the AST once and writes the CGRS code in the process"""

    def visitAST(self, node):
        """Visit the top-level AST"""
        self.outputInNamespaces = []
        self.inputInNamespaces = ['CDA', 'CGRS']

        self.cxx.out('// This file is automatically generated; do not edit.')
        self.module = node.filebase
        self.cxx.out('#include "CGRSImplementation.hpp"')
        self.cxx.out('#include "CGRSBootstrap.hpp"')
        self.cxx.out('#include "Iface' + self.module + '.hxx"')
        self.cxx.out('#include "CGRS' + self.module + '.hxx"')

        for [k, v] in self.specialIncludes:
            if k == self.module:
                self.cxx.out('#include "%s"' % v)

        for n in node.declarations():
            n.accept(self)

        self.leaveAllNamespaces()
        self.cxx.out('#endif // _INCLUDED_CGRS_%s' % node.filebase)

    def visitModule(self, node):
        """Visit all the definitions in a module."""
        self.inputInNamespaces.append(node.simplename)
        for n in node.definitions():
            if n.mainFile():
                n.accept(self)
        self.inputInNamespaces.pop()

    def enterAllNamespaces(self):
        if self.inputInNamespaces == self.outputInNamespaces:
            return
        try:
            keepDepth = map(lambda (a, b): a != b, zip(self.inputInNamespaces, self.outputInNamespaces)).index(True)
        except ValueError:
            keepDepth = min(len(self.inputInNamespaces), len(self.outputInNamespaces))

        for i in range (0, len(self.outputInNamespaces) - keepDepth):
            self.cxx.dec_indent()
            self.cxx.out('};')
        for ns in self.inputInNamespaces[keepDepth:]:
            self.cxx.out('namespace %s' % ns)
            self.cxx.out('{')
            self.cxx.inc_indent()
        self.outputInNamespaces = self.inputInNamespaces

    def leaveAllNamespaces(self):
        for i in self.outputInNamespaces:
            self.cxx.dec_indent()
            self.cxx.out('};')
        self.outputInNamespaces = []

    def visitForward(self, node):
        pass

    def recursivelyFindAncestralBases(self, node):
        ret = []
        for inh in node.inherits():
            ret.append(inh)
            ret += self.recursivelyFindAncestralBases(inh)
        return ret

    def visitInterface(self, node):
        self.iface = node.corbacxxscoped

        self.enterAllNamespaces()
        self.cxx.out('class %s' % node.simplename)
        self.cxx.out('  : public iface::CGRS::GenericInterface')
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()
        self.cxx.out('%s() {}' % node.simplename)
        self.cxx.out('~%s() {}' % node.simplename)
        self.cxx.out('CDA_IMPL_ID;')
        self.cxx.out('CDA_IMPL_REFCOUNT;')
        self.cxx.out('CDA_IMPL_QI1(CGRS::GenericInterface);')

        bases = self.recursivelyFindAncestralBases(node)
        self.cxx.out('int32_t baseCount() throw() { return %d; }' % len(bases))
        self.cxx.out('already_AddRefd<iface::CGRS::GenericInterface> getBase(int32_t aBaseName)')
        self.cxx.out('  throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out('switch (aBaseName) {')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(bases)), bases):
            self.cxx.out('case %d: return cgs->getInterfaceByName("%s");' % (i, b.simplecxxscoped))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}') # Close switch
        self.cxx.dec_indent()
        self.cxx.out('}') # Close getBase()

        # Now define classes (within this class) for attributes and operations...
        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()

        self.supportedAttributes = []
        self.supportedOperations = []
        for n in node.contents():
            n.accept(self)

        self.cxx.dec_indent()
        self.cxx.out('public:')
        self.cxx.inc_indent()

        self.cxx.out('int32_t attributeCount() throw(std::exception&) { return %d; }' % len(self.supportedAttributes))
        self.cxx.out('int32_t operationCount() throw(std::exception&) { return %d; }' % len(self.supportedOperations))

        self.cxx.out('already_AddRefd<iface::CGRS::GenericAttribute>')
        self.cxx.out('getAttributeByIndex(int32_t aAttributeNumber) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('switch (aAttributeNumber)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(self.supportedAttributes)), self.supportedAttributes):
            self.cxx.out('case %d: return new CDA::CGRS::%s::attr%s();' % (i, node.simplecxxscoped, b))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericOperation>')
        self.cxx.out('getOperationByIndex(int32_t aOperationNumber) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('switch (aOperationNumber)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        for (i, b) in zip(range(0,len(self.supportedOperations)), self.supportedOperations):
            self.cxx.out('case %d: return new CDA::CGRS::%s::meth%s();' % (i, node.simplecxxscoped, b))
        self.cxx.out('default: throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericAttribute>')
        self.cxx.out('getAttributeByName(const std::string& aAttributeName) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        elseV = ''
        for b in self.supportedAttributes:
            self.cxx.out('%sif (aAttributeName == "%s") return new CDA::CGRS::%s::attr%s();' % (elseV, b, node.simplecxxscoped, b))
            elseV = 'else '
        self.cxx.out('throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericOperation>')
        self.cxx.out('getOperationByName(const std::string& aOperationName) throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        elseV = ''
        for b in self.supportedOperations:
            self.cxx.out('%sif (aOperationName == "%s") return new CDA::CGRS::%s::meth%s();' % (elseV, b, node.simplecxxscoped, b))
            elseV = 'else '
        self.cxx.out('throw iface::CGRS::CGRSError();')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.dec_indent()
        self.cxx.out('};') # Close class

        self.cxx.out('class Callback%s' % node.simplename)
        self.cxx.out('  : public %s' % node.simplecxxscoped)
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()
        self.cxx.out('Callback%s(iface::CGRS::CallbackObjectValue* aValue)' % node.simplename)
        self.cxx.out('  : mValue(aValue)')
        self.cxx.out('{')
        self.cxx.out('}')
        self.generateCallbackFunctions(node)
        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<iface::CGRS::CallbackObjectValue> mValue;')
        self.cxx.dec_indent()
        self.cxx.out('};')

    def generateCallbackFunctions(self, node):
        for d in node.inherits():
            self.generateCallbackFunctions(d)
        if node.simplecxxname == "iface::XPCOM::IObject":
            TODO: Implement special IObject functions....
            return
        for d in node.callables():
            if isinstance(d, Operation):
                self.generateCallbackFunction(\
                    d.simplename, d.returnType(),\
                    map(lambda x: (x.identifer(), x.is_in(), x.is_out()),\
                            d.parameters()))
            elif isinstance(a, Attribute):
                for d in a.declarators():
                    self.generateCallbackFunction(\
                        d.simplename, a.attrType(), [])
                    if a.readonly():
                        self.generateCallbackFunction(\
                            d.simplename, None, [(a.attrType(), 1, 0)])

    def visitTypedef(self, node):
        pass

    def visitMember(self, node):
        pass

    def visitStruct(self, node):
        raise "Structs are not supported"

    def visitUnion(self, node):
        raise "Unions are not supported"

    def visitEnumerator(self, node):
        pass

    def visitEnum(self, node):
        pass
    
    def visitException(self, node):
        pass

    def visitOperation(self, op):
        self.supportedOperations.append(op.simplename)
        self.generateMethod(op.simplename, op.simplename, op.returnType(), map(lambda p: (p.identifier(), p.paramType(),
                                                                                          p.is_in(), p.is_out()), op.parameters()))
        self.cxx.out('class %s' % (op.simplename))
        self.cxx.out('  : public iface::CGRS::GenericMethod')
        self.cxx.out('{')
        self.cxx.out('};')

    def generateMethod(self, classname, cxxmethodname, retType, params):
        self.cxx.out('class meth%s' % classname)
        self.cxx.out('  : public iface::CGRS::GenericMethod')
        self.cxx.out('{')
        self.cxx.out('public:')
        self.cxx.inc_indent()

        self.cxx.out('CDA_IMPL_REFCOUNT;')
        self.cxx.out('CDA_IMPL_ID;')
        self.cxx.out('CDA_IMPL_QI1(CGRS::GenericMethod);')
        self.cxx.out('std::vector<iface::CGRS::GenericParameter*> parameters() throw()')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('std::vector<iface::CGRS::GenericParameter*> params;')

        for (pname, ptype, pIsIn, pIsOut) in params:
            self.cxx.out('params.push_back(new Param%s());' % pname)

        self.cxx.out('return params;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericType> returnType() throw()')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out(GetTypeInformation(retType).fetchType())
        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.out('already_AddRefd<iface::CGRS::GenericValue>')
        self.cxx.out('invoke(iface::CGRS::ObjectValue* aInvokeOn, const std::vector<iface::CGRS::GenericValue>& aInValues,')
        self.cxx.out('       std::vector<iface::CGRS::GenericValue>& aOutValues, bool& aWasException)')
        self.cxx.out('  throw(std::exception&)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out('ObjRef<CDA_GenericsService> cgs = CreateGenericsServiceInternal();')
        self.cxx.out('if (aInvokeOn == NULL) throw iface::CGRS::CGRSError();')
        self.cxx.out('ObjRef<iface::XPCOM::IObject> obj = aInvokeOn->asObject());')
        self.cxx.out('DECLARE_QUERY_INTERFACE_OBJREF(obji, obj, %s);' % self.iface)
        self.cxx.out('if (obji == NULL) throw iface::CGRS::CGRSError();')

        incnt = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            if pIsIn:
                incnt = incnt + 1
        self.cxx.out('if (aInValues.size() != %d) throw iface::CGRS::CGRSError();' % incnt)
        
        inidx = 0
        pidx = 0
        paramstring = ''
        for (pname, ptype, pIsIn, pIsOut) in params:
            ti = GetTypeInformation(ptype)
            self.cxx.out(ti.makeStorage('param%d' % pidx))
            if pIsIn:
                self.cxx.out(ti.convertGenericToNative('aInValues[%d]' % inidx, 'param%d' % pidx))
                inidx = inidx + 1
            if pidx != 0:
                paramstring = paramstring + ', '
            paramstring = paramstring + 'param%d' % pidx
            pidx = pidx + 1

        rti = GetTypeInformation(retType)
        self.cxx.out(rti.makeStorage('retval'))
        self.cxx.out('aWasException = false;')
        self.cxx.out('try')
        self.cxx.out('{')
        self.cxx.inc_indent()
        if rti.typename == 'void':
            retAssign = ''
        else:
            retAssign = 'retval = '
        self.cxx.out('%sobji->%s(%s);' % (retAssign, cxxmethodname, paramstring))
        self.cxx.dec_indent()
        self.cxx.out('}')
        self.cxx.out('catch (...)')
        self.cxx.out('{')
        self.cxx.inc_indent()
        self.cxx.out(rti.defaultStorageValue('retval'))
        pidx = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            if pIsOut:
                self.cxx.out(rti.defaultStorageValue('param%d' % pidx))
            pidx = pidx + 1
        self.cxx.out('aWasException = true;')
        self.cxx.dec_indent()
        self.cxx.out('}')

        pidx = 0
        for (pname, ptype, pIsIn, pIsOut) in params:
            ti = GetTypeInformation(ptype)
            if pIsOut:
                self.cxx.out('{')
                self.cxx.inc_indent()
                self.cxx.out('iface::CGRS::GenericValue* gval;')
                self.cxx.out(ti.convertNativeToGeneric('param%d' % pidx, 'gval'))
                self.cxx.out('aOutValues.push_back(gval);')
                self.cxx.dec_indent()
                self.cxx.out('}')
            self.cxx.out(ti.destroyStorage('param%d' % pidx))
            pidx = pidx + 1

        if rti.typename != 'void':
            self.cxx.out('ObjRef<iface::CGRS::GenericValue> gretval;')
            self.cxx.out(rti.convertNativeToGeneric('retval', 'gretval'))
            self.cxx.out('return gretval;')

        self.cxx.dec_indent()
        self.cxx.out('}')

        self.cxx.dec_indent()
        self.cxx.out('private:')
        self.cxx.inc_indent()

        for (pname, ptype, pIsIn, pIsOut) in params:
            self.cxx.out('class Param%s' % pname)
            self.cxx.out('  : public GenericParameter')
            self.cxx.out('{')
            self.cxx.out('public:')
            self.cxx.inc_indent()
            self.cxx.out('CDA_IMPL_ID;')
            self.cxx.out('CDA_IMPL_REFCOUNT;')
            self.cxx.out('CDA_IMPL_QI1(CGRS::GenericParameter);')
            self.cxx.out('bool isIn() throw() { return ' + ("true" if pIsIn else "false") + "; }")
            self.cxx.out('bool isOut() throw() { return ' + ("true" if pIsOut else "false") + "; }")
            self.cxx.out('std::string name() throw() { return "%s"; }' % pname)
            self.cxx.out('already_AddRefd<iface::CGRS::GenericType> type() throw()')
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out(GetTypeInformation(ptype).fetchType())
            self.cxx.dec_indent()
            self.cxx.out('}')
            self.cxx.dec_indent()
            self.cxx.out('};')
        self.cxx.dec_indent()
        self.cxx.out('};')

    def visitAttribute(self, at):
        for n in at.declarators():
            self.supportedAttributes.append(n.simplename)
            self.generateMethod('get%s' % n.simplename, n.simplename, at.attrType(), [])
            if not at.readonly():
                self.generateMethod('set%s' % n.simplename, n.simplename, None, [("value", at.attrType(), 1, 0)])

            self.cxx.out('class attr%s' % n.simplename)
            self.cxx.out('  : public iface::CGRS::GenericAttribute')
            self.cxx.out('{')
            self.cxx.out('public:')
            self.cxx.inc_indent()
            self.cxx.out('CDA_IMPL_REFCOUNT;')
            self.cxx.out('CDA_IMPL_ID;')
            self.cxx.out('CDA_IMPL_QI1(CGRS::GenericAttribute);')
            self.cxx.out('bool isReadonly() throw() { return %s; }' % ("true" if at.readonly() else "false"))
            self.cxx.out('std::string name() throw() { return "%s"; }' % n.simplename)
            self.cxx.out('already_AddRefd<iface::CGRS::GenericType> type() throw()')
            self.cxx.out('{')
            self.cxx.inc_indent()
            self.cxx.out(GetTypeInformation(at.attrType()).fetchType())
            self.cxx.dec_indent()
            self.cxx.out('}')
            self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> getter() throw() { return new get%s(); }' % n.simplename)
            if at.readonly():
                self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> setter() throw(iface::CGRS::CGRSError) { throw iface::CGRS::CGRSError(); }')
            else:
                self.cxx.out('already_AddRefd<iface::CGRS::GenericMethod> setter() throw() { return new set%s(); }' % n.simplename)
            self.cxx.dec_indent()
            self.cxx.out('};')
